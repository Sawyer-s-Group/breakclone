#' @import data.table

#' @title Read allele-specific copy number data from a directory
#'
#' @description Read in allele-specific copy number data from tab- or comma- separated files. Required fields in each file are the chromosome name, start and end coordinates,
#' the number of probes in each segment, the minor copy number and either the major or total copy number.
#'
#' @param directory A directory containing the files.
#' @param pattern The filename pattern matching the files.
#' @param sample.field Name of the sample ID column. If set to NULL, filenames will be used.
#' @param chr.field Name of the chromosome column.
#' @param start.field Name of the start coordinate column.
#' @param end.field Name of the end coordinate column.
#' @param nprobes.field Name of the per-segment number of probes column.
#' @param nmajor.field Name of the major copy number column.
#' @param nminor.field Name of the minor copy number column.
#' @param ntotal.field Name of the total copy number column (ignored if \code{nmajor.field} is set).
#' @author argymeg
#' @return A data.table with column names SampleID, Chr, Start, End, nProbes, nMajor, nMinor.
#' @export
readAlleleSpecific <- function(directory, pattern = "*_Segments_AbsCN_alleleSpecific.txt", sample.field = "SampleID",
                               chr.field = "Chr", start.field = "Start", end.field = "End", nprobes.field = "nProbes",
                               nmajor.field = "nMajor", nminor.field = "nMinor", ntotal.field = NULL) {
  fileList <- dir(directory, pattern, full.names = TRUE)
  segmentList <- lapply(fileList, data.table::fread)
  if (is.null(sample.field)) {
    segmentList <- mapply(cbind.data.frame, segmentList, basename(fileList), SIMPLIFY = FALSE)
  }
  segmentTable <- data.table::rbindlist(segmentList)
  if (is.null(sample.field)) {
    sample.field <- "SampleID"
    names(segmentTable)[ncol(segmentTable)] <- "SampleID"
  }

  if (is.null(nmajor.field)) {
    nmajor.field <- "nMajor"
    segmentTable[, nmajor.field] <- segmentTable[, ..ntotal.field] - segmentTable[, ..nminor.field]
  }

  cols_needed <- c(sample.field, chr.field, start.field, end.field, nprobes.field, nmajor.field, nminor.field)
  colnames_needed <- c("SampleID", "Chr", "Start", "End", "nProbes", "nMajor", "nMinor")
  segmentTable <- segmentTable[, ..cols_needed]
  names(segmentTable) <- colnames_needed


  return(segmentTable)
}

#' Read in copy number VCF files
#'
#' Read in copy number data from standard VCF files
#' @param directory A directory containing the files.
#' @param pattern The filename pattern matching the files.
#' @author argymeg
#' @return A data.table with column names SampleID, Chr, Start, End, Bins, SVType, Length.
#' @export
readVCFCn <- function(directory, pattern = "*.vcf") {
  parseVCF <- function(x) {
    vcf <- vcfR::read.vcfR(x, verbose = FALSE)
    extracted_fields <- vcfR::vcfR2tidy(vcf, info_only = TRUE, info_fields = c("SVTYPE", "END", "BINS", "SVLEN"))$fix[, c("CHROM", "POS", "END", "BINS", "SVTYPE", "SVLEN")]
    samplename <- colnames(vcf@gt)[2]
    return(cbind(samplename, extracted_fields, stringsAsFactors = FALSE))
  }
  fileList <- dir(directory, pattern, full.names = TRUE)
  segmentList <- lapply(fileList, parseVCF)
  segmentList <- segmentList[!unlist(lapply(segmentList, function(x) {
    any(is.na(x))
  }))]
  segmentTable <- data.table::rbindlist(segmentList)
  colnames(segmentTable) <- c("SampleID", "Chr", "Start", "End", "Bins", "SVType", "Length")
  return(segmentTable)
}

#' Infer tumour pairs from segment table
#'
#' If sample IDs comprise a patient ID and a tumour type identifier, this function can attempt to infer the tumour pairs from the cohort.
#' @param segmentTable A segment or mutation table generated by the appropriate read function
#' @param delimiter The separator between patient and tumour identifiers in the sample names
#' @author argymeg, updated by Maria Roman Escorza
#' @return A data.frame with column names Sample1 and Sample2 and Patient
#' @export
inferPairs <- function(segmentTable, delimiter = "_") {
  # Extract sample IDs from segmentTable
  samples <- unique(segmentTable$SampleID)

  # Extract patient ID
  patients <- sub(paste0(delimiter, ".+"), "", samples)

  # Group samples by patient ID
  splitSamples <- split(samples, patients)

  # Generate all possible combinations for each patient
  pairs <- lapply(splitSamples, function(patientSamples) {
    if (length(patientSamples) < 2) return(NULL)  # Skip patients with fewer than 2 samples
    combn(patientSamples, 2, simplify = FALSE)
  })

  # Combine into a data.table
  pairs <- rbindlist(lapply(pairs, function(pairs) {
    if (is.null(pairs)) return(NULL)  # Skip NULL results
    do.call(rbind, lapply(pairs, function(pair) {
      data.table(Sample1 = pair[1], Sample2 = pair[2])
    }))
  }), use.names = TRUE)

  pairs$Patient <- sub(paste0(delimiter, ".+"), "", pairs$Sample1)

  return(pairs)
}

#' Read in mutation VCF files
#'
#' Read in mutation from standard VCF files
#' @param directory A directory containing the files.
#' @param pattern The filename pattern matching the files.
#' @author argymeg
#' @return A data.table with column names SampleID, Chr, Pos, AF.
#' @export
readVCFMutations <- function(directory, pattern = "*.vcf") {
  parseVCF <- function(x) {
    vcf <- vcfR::read.vcfR(x, verbose = FALSE)
    extracted_fields <- vcfR::vcfR2tidy(vcf, single_frame = TRUE, verbose = FALSE)$dat
    extracted_fields <- extracted_fields[, c("CHROM", "POS", "Indiv", "gt_AF")]
    extracted_fields <- extracted_fields[order(extracted_fields$Indiv), ]
    return(extracted_fields)
  }
  fileList <- dir(directory, pattern, full.names = TRUE)
  segmentList <- lapply(fileList, parseVCF)
  segmentList <- segmentList[!unlist(lapply(segmentList, function(x) {
    any(is.na(x))
  }))]
  segmentTable <- data.table::rbindlist(segmentList)
  colnames(segmentTable) <- c("Chr", "Pos", "SampleID", "AF")
  segmentTable$AF <- as.numeric(segmentTable$AF)
  segmentTable <- na.omit(segmentTable)
  return(segmentTable)
}
